# Тестовое задание на позицию стажёра C++

Репозиторий содержит решение двух задач тестового задания.

## Структура проекта
- `Task1/` — Реализация драйвера EEPROM 25LC040A (C++).
- `Task2/` — Кастомный аллокатор памяти (C).

---

## Задание 1: Драйвер EEPROM (SPI)

### Описание реализации
Реализован многоуровневый подход для работы с памятью:
1. **SpiDriver** — класс нижнего уровня, реализующий протокол SPI методом "bit-banging". 
2. **Eeprom25LC040A** — класс верхнего уровня, реализующий логику конкретной микросхемы (команды, 9-битная адресация, ожидание завершения записи).

### Особенности:
- Реализована поддержка чтения/записи как одиночных байт, так и массивов.
- Обработка 9-го бита адреса (A8) реализована внутри класса согласно спецификации (встраивание в байт инструкции).
- Для безопасной записи реализован механизм опроса регистра статуса.
- Код документирован в формате **Doxygen**.

### Как запустить демо:
В папке `Task1` находится `main.cpp`. Так как реальное оборудование отсутствует, `SpiDriver` использует заглушки. Запуск программы демонстрирует в консоли последовательность реально отправляемых байт (команд и данных).

### Ответ на вопрос: Что изменится для NOR памяти (W25Q128)?
При переходе на работу с NOR Flash памятью (например, W25Q128) потребуются следующие изменения:
1. **Адресация:** W25Q128 имеет объем 128 Мбит, что требует 24-битного адреса (3 байта) вместо 9-битного.
2. **Управление памятью:** В отличие от EEPROM, память NOR Flash требует обязательного стирания сектора перед записью данных в него.
3. **Команды:** Набор команд в целом похож, но добавляются специфичные для Flash команды (чтение JEDEC ID, разные режимы стирания).

---

## Задание 2: Кастомный аллокатор памяти (C)

### Описание реализации
Реализован быстрый аллокатор для блоков фиксированного размера (15 и 180 байт). 

### Технические особенности:
- **Memory Pools:** Память выделена заранее в виде статических массивов. Это исключает фрагментацию и обращение к системному `malloc`.
- **O(1) Complexity:** Поиск свободного блока и его освобождение происходят за константное время. Используется структура **Singly Linked List (Free List)** внутри свободных блоков.
- **Выравнивание:** Блок размером 15 байт автоматически выровнен до 16 байт для обеспечения корректной работы указателей на 32-битных архитектурах.
- **Универсальность:** Код написан с использованием типов `size_t` и `void*`, что обеспечивает работоспособность на 8, 16 и 32-битных платформах.
- **Инкапсуляция:** Служебные структуры и пулы памяти скрыты внутри `.c` файла и недоступны пользователю библиотеки.

### Как запустить:
В папке `Task2` находится `main.c` с набором тестов:
1. Выделение блоков разных размеров.
2. Проверка повторного использования памяти после освобождения (LIFO).
3. Проверка защиты от некорректных запросов (выделение > 180 байт).
